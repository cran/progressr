<!DOCTYPE html>
<html lang="en">
<head>
<title>progressr: An Introduction</title>
<style>
body {
  font-family: sans-serif;
  line-height: 1.6;
  padding-left: 3ex;
  padding-right: 3ex;
  background-color: white;
  color: black;
}

a {
  color: #4183C4;
  text-decoration: none;
}

h1, h2, h3 {
  margin: 2ex 0 1ex;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative;
}

h2 {
  border-bottom: 1px solid #cccccc;
}

code {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  line-height: 2.5x;
  overflow: auto;
  padding: 0.6ex 1ex;
  border-radius: 3px;
}

pre code {
  background-color: transparent;
  border: none;
}
</style>
</head>
<body>
<h1>progressr: An Introduction</h1>
<!-- DO NOT EDIT THIS FILE! Edit 'OVERVIEW.md' instead and then rebuild this file with 'make vigs' -->
<p><img src="imgs/lifecycle-experimental-orange.svg" alt="Life cycle: experimental" /></p>
<p>The <strong><a href="https://github.com/HenrikBengtsson/progressr/">progressr</a></strong> package provides a minimal API for reporting progress updates in <a href="https://www.r-project.org/">R</a>.  The design is to separate the representation of progress updates from how they are presented.  What type of progress to signal is controlled by the developer.  How these progress updates are rendered is controlled by the end user.  For instance, some users may prefer visual feedback such as a horizontal progress bar in the terminal, whereas others may prefer auditory feedback.</p>
<img src="imgs/three_in_chinese.gif" alt="Three strokes writing three in Chinese" style="float: right; margin-right: 1ex; margin-left: 1ex;"/>
<p>Design motto:</p>
<blockquote>
<p>The developer is responsible for providing progress updates but it's only the end user who decides if, when, and how progress should be presented. No exceptions will be allowed.</p>
</blockquote>
<h2>Two Minimal APIs</h2>
<table>
<thead>
<tr>
<th>Developer's API</th>
<th>End-user's API</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p &lt;- progressor(n)</code></td>
<td><code>with_progress(expr)</code></td>
</tr>
<tr>
<td><code>p &lt;- progressor(along = x)</code></td>
<td><code>handlers(...)</code></td>
</tr>
<tr>
<td><code>p(msg, ...)</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2>A simple example</h2>
<p>Assume that we have a function <code>slow_sum()</code> for adding up the values in a vector.  It is so slow, that we like to provide progress updates to whoever might be interested in it.  With the <strong>progressr</strong> package, this can be done as:</p>
<pre><code class="language-r">slow_sum &lt;- function(x) {
  p &lt;- progressr::progressor(along = x)
  sum &lt;- 0
  for (kk in seq_along(x)) {
    Sys.sleep(0.1)
    sum &lt;- sum + x[kk]
    p(message = sprintf(&quot;Added %g&quot;, x[kk]))
  }
  sum
}
</code></pre>
<p>Note how there are <em>no</em> arguments in the code that specifies how progress is presented.  The only task for the developer is to decide on where in the code it makes sense to signal that progress has been made.  As we will see next, it is up to the end user of this code to decide whether they want to receive progress updates or not, and, if so, in what format.</p>
<h3>Without reporting progress</h3>
<p>When calling this function as in:</p>
<pre><code class="language-r">&gt; y &lt;- slow_sum(1:10)
&gt; y
[1] 55
&gt;
</code></pre>
<p>it will behave as any function and there will be no progress updates displayed.</p>
<h3>Reporting progress</h3>
<p>To get progress updates, we can call it as:</p>
<pre><code class="language-r">&gt; library(progressr)
&gt; with_progress(y &lt;- slow_sum(1:10))
  |=====================                                |  40%
</code></pre>
<h2>Customizing how progress is reported</h2>
<p>The default is to present progress via <code>utils::txtProgressBar()</code>, which is available on all R installations.  To change the default, to, say, <code>progress_bar()</code> by the <strong><a href="https://cran.r-project.org/package=progress">progress</a></strong> package, set:</p>
<pre><code class="language-r">handlers(&quot;progress&quot;)
</code></pre>
<p>This progress handler will present itself as:</p>
<pre><code class="language-r">&gt; with_progress(y &lt;- slow_sum(1:10))
[==================&gt;---------------------------]  40% Added 4
</code></pre>
<p>To set the default progress handler(s) in all your R sessions, call <code>progressr::handlers(...)</code> in your <code>~/.Rprofile</code> file.</p>
<h3>Auditory progress updates</h3>
<p>Note all progress updates have to be presented visually. This can equally well be done auditory. For example, using:</p>
<pre><code class="language-r">handlers(&quot;beepr&quot;)
</code></pre>
<p>will present itself as sounds played at the beginning, while progressing, and at the end (using different <strong><a href="https://cran.r-project.org/package=beepr">beepr</a></strong> sounds).  There will be <em>no</em> output written to the terminal;</p>
<pre><code class="language-r">&gt; with_progress(y &lt;- slow_sum(1:10))
&gt; y
[1] 55
&gt;
</code></pre>
<h3>Concurrent auditory and visual progress updates</h3>
<p>It is possible to have multiple progress handlers presenting progress updates at the same time.  For example, to get both visual and auditory updates, use:</p>
<pre><code class="language-r">handlers(&quot;txtprogressbar&quot;, &quot;beepr&quot;)
</code></pre>
<h2>Support for progressr elsewhere</h2>
<p>Note that progression updates by <strong>progressr</strong> is designed to work out of the box for any <em>sequential</em> iterator framework in R.  Below is an set of examples for the most common ones.</p>
<h3>Base R Apply Functions</h3>
<pre><code class="language-r">library(progressr)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- lapply(xs, function(x) {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(0.1)
    sqrt(x)
  })
})
#  |=====================                                |  40%
</code></pre>
<h3>The foreach package</h3>
<pre><code class="language-r">library(foreach)
library(progressr)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- foreach(x = xs) %do% {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(0.1)
    sqrt(x)
  }
})
#  |=====================                                |  40%
</code></pre>
<h3>The purrr package</h3>
<pre><code class="language-r">library(purrr)
library(progressr)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- map(xs, function(x) {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(0.1)
    sqrt(x)
  })
})
#  |=====================                                |  40%
</code></pre>
<h3>The plyr package</h3>
<p>The functions in the <a href="https://cran.r-project.org/package=plyr"><strong>plyr</strong></a> package take argument <code>.progress</code>, which can be used to produce progress updates.  To have them generate <strong>progressr</strong> 'progression' updates, use <code>.progress = &quot;progressr&quot;</code>. For example,</p>
<pre><code class="language-r">library(plyr)
library(progressr)

xs &lt;- 1:5

with_progress({
  y &lt;- llply(xs, function(x, ...) {
    Sys.sleep(0.1)
    sqrt(x)
  }, .progress = &quot;progressr&quot;)
})
#  |=====================                                |  40%
</code></pre>
<h2>Parallel processing and progress updates</h2>
<p>The <strong><a href="https://cran.r-project.org/package=future">future</a></strong> framework, which provides a unified API for parallel and distributed processing in R, has built-in support for the kind of progression updates produced by the <strong>progressr</strong> package.  This means that you can use it with for instance <strong><a href="https://cran.r-project.org/package=future.apply">future.apply</a></strong>, <strong><a href="https://cran.r-project.org/package=furrr">furrr</a></strong>, and <strong><a href="https://cran.r-project.org/package=foreach">foreach</a></strong> with <strong><a href="https://cran.r-project.org/package=doFuture">doFuture</a></strong>.</p>
<h3>future_lapply() - parallel lapply()</h3>
<p>Here is an example that uses <code>future_lapply()</code> of the <strong><a href="https://cran.r-project.org/package=future.apply">future.apply</a></strong> package to parallelize on the local machine while at the same time signaling progression updates:</p>
<pre><code class="language-r">library(future.apply)
plan(multisession)

library(progressr)
handlers(&quot;progress&quot;, &quot;beepr&quot;)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- future_lapply(xs, function(x, ...) {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(6.0-x)
    sqrt(x)
  })
})
## [=================&gt;-----------------------------]  40% x=2
</code></pre>
<h3>foreach() with doFuture</h3>
<p>Here is an example that uses <code>foreach()</code> of the <strong><a href="https://cran.r-project.org/package=foreach">foreach</a></strong> package to parallelize on the local machine (via <strong><a href="https://cran.r-project.org/package=doFuture">doFuture</a></strong>) while at the same time signaling progression updates:</p>
<pre><code class="language-r">library(doFuture)
registerDoFuture()
plan(multisession)

library(progressr)
handlers(&quot;progress&quot;, &quot;beepr&quot;)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- foreach(x = xs) %dopar% {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(6.0-x)
    sqrt(x)
  }
})
## [=================&gt;-----------------------------]  40% x=2
</code></pre>
<h3>future_map() - parallel purrr::map()</h3>
<pre><code class="language-r">library(furrr)
plan(multisession)

library(progressr)
handlers(&quot;progress&quot;, &quot;beepr&quot;)

xs &lt;- 1:5

with_progress({
  p &lt;- progressor(along = xs)
  y &lt;- future_map(xs, function(x) {
    p(sprintf(&quot;x=%g&quot;, x))
    Sys.sleep(6.0-x)
    sqrt(x)
  })
})
## [=================&gt;-----------------------------]  40% x=2
</code></pre>
<h3>The plyr package</h3>
<p>Unfortunately, when using <code>.parallel = TRUE</code>, the <strong>plyr</strong> package resets <code>.progress</code> to the default <code>&quot;none&quot;</code> internally regardless how we set <code>.progress</code>.  This prevents <strong>progressr</strong> progression updates from being used with <em>parallel</em> <strong>plyr</strong>.  If it was not for this forced reset, using <code>doFuture::registerDoFuture()</code> with <code>.parallel = TRUE</code> and <code>.progress = &quot;progressr&quot;</code> would indeed have reported on progress updates also when <strong>plyr</strong> runs in parallel.  See <a href="https://github.com/HenrikBengtsson/progressr/issues/70">https://github.com/HenrikBengtsson/progressr/issues/70</a> for a hack that works around this limitation.</p>
<h2>Roadmap</h2>
<p>Because this project is under active development, the progressr API is currently kept at a very minimum.  This will allow for the framework and the API to evolve while minimizing the risk for breaking code that depends on it.  The roadmap for developing the API is roughly:</p>
<ol>
<li>
<p>Provide minimal API for producing progress updates, i.e. <code>progressor()</code> and <code>with_progress()</code></p>
</li>
<li>
<p>Add support for nested progress updates</p>
</li>
<li>
<p>Add API to allow users and package developers to design additional progression handlers</p>
</li>
</ol>
<p>For a more up-to-date view on what features might be added, see <a href="https://github.com/HenrikBengtsson/progressr/issues">https://github.com/HenrikBengtsson/progressr/issues</a>.</p>
<h2>Appendix</h2>
<h3>Under the hood</h3>
<p>When using the <strong>progressr</strong> package, progression updates are communicated via R's condition framework, which provides methods for creating, signaling, capturing, muffling, and relaying conditions.  Progression updates are of classes <code>progression</code> and <code>immediateCondition</code>(*).  The below figure gives an example how progression conditions are created, signaled, and rendered.</p>
<p>(*) The <code>immediateCondition</code> class of conditions are relayed as soon as possible by the <strong><a href="https://cran.r-project.org/package=future">future</a></strong> framework, which means that progression updates produced in parallel workers are reported to the end user as soon as the main R session have received them.</p>
<p><img src="imgs/slow_sum.svg" alt="" /></p>
<p><em>Figure: Sequence diagram illustrating how signaled progression conditions are captured by <code>with_progress()</code> and relayed to the two progression handlers 'progress' (a progress bar in the terminal) and 'beepr' (auditory) that the end user has chosen.</em></p>
<h3>Debugging</h3>
<p>To debug progress updates, use:</p>
<pre><code class="language-r">&gt; handlers(&quot;debug&quot;)
&gt; with_progress(y &lt;- slow_sum(1:10))
[13:33:49.743] (0.000s =&gt; +0.002s) initiate: 0/10 (+0) '' {clear=TRUE, enabled=TRUE, status=}
[13:33:49.847] (0.104s =&gt; +0.001s) update: 1/10 (+1) 'Added 1' {clear=TRUE, enabled=TRUE, status=}
[13:33:49.950] (0.206s =&gt; +0.001s) update: 2/10 (+1) 'Added 2' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.052] (0.309s =&gt; +0.000s) update: 3/10 (+1) 'Added 3' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.154] (0.411s =&gt; +0.001s) update: 4/10 (+1) 'Added 4' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.257] (0.514s =&gt; +0.001s) update: 5/10 (+1) 'Added 5' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.361] (0.618s =&gt; +0.002s) update: 6/10 (+1) 'Added 6' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.464] (0.721s =&gt; +0.001s) update: 7/10 (+1) 'Added 7' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.567] (0.824s =&gt; +0.001s) update: 8/10 (+1) 'Added 8' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.670] (0.927s =&gt; +0.001s) update: 9/10 (+1) 'Added 9' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.773] (1.030s =&gt; +0.001s) update: 10/10 (+1) 'Added 10' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.774] (1.031s =&gt; +0.003s) update: 10/10 (+0) 'Added 10' {clear=TRUE, enabled=TRUE, status=}
[13:33:50.776] (1.033s =&gt; +0.001s) shutdown: 10/10 (+0) '' {clear=TRUE, enabled=TRUE, status=ok}
</code></pre>

</body>
</html>
